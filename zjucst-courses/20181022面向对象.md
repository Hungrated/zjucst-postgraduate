20181022面向对象

Java泛型

将运行时错误提前到编译前解决
参量多态：主要解决类型安全问题

术语 那张表

使用泛型 那张图

泛型方法：1 跟着泛型类定义 2 类并不是泛型类，单独对方法设定类型参数

泛型可以扩展特性接口（T extends Comparable） 表示泛型类必须实现该特性接口（如Comparable）来限定泛型必须是何种类型
基本泛型类具备Object类的接口
泛型可以套用基类 接口（T super SuperType） 表示更一般特性的类型 并不表示继承关系

数组与泛型
类型擦除 编译器知道类型的存在，但在自检码中类型被擦除 目的是实现向下兼容性

数组中使用泛型不要用继承
泛型在类中不要直接实例化（unchecked，可能报错） 应该先new Object 再强制类型转换

泛型通配符’?’
<? extends SomeClass>
要求方法中使用到该泛型的时候不允许修改类型

不要用原始类型（不带泛型）来创建新对象
原始类型与带通配符的泛型区别：通配符是类型安全的，避免了null的传入

消除类型未检查的警告
检查代码，确定不会出现类型问题后，使用注解：@SuppressWarnings(“unchecked”)

更推荐使用List而不是Array
泛型只在编译时存在 编译之后不存在

泛型类型相关
搞懂extends super


枚举

枚举是Java通用类
使用枚举代替整型常量
Int枚举的一些缺陷：1 缺乏类型安全 2 脆弱的程序 3 难以迭代 4 String类型枚举模式比较糟糕
Java枚举类型：1 每个常量都有一个实例 2 保证编译时类型安全 3 每个枚举有自己的命名空间 4 新类型加进时不用重编译客户代码 5 更多

用继承结构来替换Switch语句（加入新case不用修改主类代码）

特定于常量的方法实现

注解

注解的三个作用 1 检查代码是否有问题 2 屏蔽编译警告 3 用于单元测试等表达具体含义的场景

注解可以跟参数

JDK注解表 那张表

自定义注解 public @interface Test {}

使用@Override注解 继承基类的方法时建议都添加

考试例子 没有加override造成错误

Item49考试例子 原始类型（不是对象）与包装类型（是对象）null能否表达的区别 性能上原始类型更优 比较大小的例子

